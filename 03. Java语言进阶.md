## Java语言进阶

### 编码规范

```java
起名:
      1):都得遵循标识符的规范.
      2):不能使用拼音,拼音首字母,使用英文单词,或者使用英文组合单词.
      3):采用驼峰表示法,使用组合单词的使用,以后的每一个单词首字母都大写.
          EmployeeAdvanceSetting.

1:包名:
       package    域名倒写.模块名.组件;
       package    com._520it.pss.util;
       package    com.m520it.pss.util;
       全部使用小写字母,作为Java文件得第一行代码.
2:类名:
      使用名词,表示一类事物,首字母大写.
       如果我们在项目中尽量不要使用JDK内置的类名,比如String ,System类.
      讲解知识点:    XxxDemo,XxxTest,(Xxx表示知识点的意思),比如:StringDemo.java.

3:接口名:
      使用形容词/副词/名词,首字母大写.
      在有的企业,习惯以I作为接口的前缀名. IEmployeeDAO/IEmployeeService.

4:方法名:
       使用动词,首字母小写,save/deleteEmployee.

5:变量:
       使用名词,首字母小写,如name/age,.

6:常量:
       使用final修饰的变量.
       全部使用大写字母组成,如果使用多个单词组合使用下划线分割,如:Integer类:MAX_VALUE:
       在方法中定义的final变量,一般不使用大写.
```

### 工具

Eclipse...

### 异常

```java
类 Throwable
已实现的接口 Serializable
子类 Error, Exception

Throwable是所有错误和异常的父类
```

```Java
Error:表示错误, 一般指JVM相关的不可修复的错误
	如, 系统崩溃,内存溢出,JVM错误等,由JVM抛出, 我们不需要处理.
	几乎所有的子类都是以Error作为类名的后缀.
常见的Error:
	StackOverflowError: 当应用程序递归太深而发生内存溢出时，抛出该错误。 

Exception:表示异常, 指程序中出现不正常的情况, 该问题可以修复(处理异常).
	几乎所有的子类都是以Exception作为类名的后缀.
常见的Exception:
    NullPointerException: 空指针异常,一般指当对象为null的时候,调用了该对象的方法,字段
    ArrayIndexOutOfBoundsException: 数组的索引越界,(小于0或者大于等于数组长度)
    NumberFormatException: 数字格式化异常, 一般指,把非0~9的字符串转换为整数
```

#### 捕获体系

```java
使用try-catch捕获单个异常,语法如下:
try{
	// 编写可能会出现异常的代码
} catch(异常类型A e){
	// 处理异常的代码
	// 记录日志/打印异常信息/继续抛出异常
} catch(异常类型B e) {
	// ...
}

```

获取异常信息

```java
- String getMessage(); 获取异常的描述信息 ,原因(提示给用户的时候, 就提示错误原因).
- String toString(); 获取异常的类型和异常描述信息(不用)
- void printStackTrace(); 打印异常的跟踪栈信息并输出到控制台.
	包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace
```

```java
try {
	int ret = 10 / 0;
} catch (ArithmeticException e) {
	// 算术异常
	e.printStackTrace();
} catch (NumberFormatException e) {
	// ...
} catch (Exception e) {
	// 都不属于上述异常类型
	// 放在最后
}
```

#### finally代码块

```java
finally语句块表示最终都会执行的代码,无论有没有异常

try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等)
在使用完之后,最终关闭打开的资源

finally的两种语法:
1. try...finally
2. try...catch....finally
```

```java
当只有在try或者catch中调用退出JVM的相关方法finally才不会执行, 否则finally永远会执行
System.exit(0); //退出JVM
```

```java
如果finally有return语句, 永远返回finally中的结果,避免该情况

// 结果为100
private static int test() {
	try {
		return 1;
	} finally {
		return 100;
	}
}
```

#### 异常分类

根据在编译时期还是运行时期去检查异常

```java
1):编译时期异常
	checked异常.在编译时期,就会检查,如果没有处理异常,则编译失败.
2):运行时期异常
	runtime异常.在运行时期,检查异常
```

```java
Throwable
	Error
	Exception
		RuntimeException
		编译时异常
```

#### 抛出异常

```java
throw: 方法内部
给调用者返回一个异常对象, 和return一样会结束当前方法
public char charAt(int index) {
	if ((index < 0) || (index >= value.length)) {
		throw new StringIndexOutOfBoundsException(index);
	}
	return value(index);
}

throws: 方法声明
表示当前方法不处理异常, 而是提醒该方法的调用者来处理异常(抛出异常)
private static int divide(int num1, int num2) throws Exception {}
```

```java
如果每一个方法都放弃处理异常都, 直接通过throws声明抛出
最后异常会抛到main方法, 如果此时main方法不处理,继续抛出给JVM
底层的处理机制就是打印异常的跟踪栈信息
```

#### Java7异常新特性

```java
// java7中处理抛出异常更精确, 不再笼统的使用Exception声明抛出
private static void doWork() throws Exception() (java6)
private static void doWork() throws FileNotFoundException() (java6)

// java7之前需要手动关闭资源
OutputStream out = null;
try {
	//打开资源对象
	out = new FileOutputStream("C://123.txt");
} catch(Exception e){
	e.printStrackTrace();
} finally {
	// 关闭资源, 代码, 没有技术含量
	try {
		if (out != null) {
			out.close();
		}
	} catch (Exception e) {
		e.printStrackTrace();
	}
}

// java7开始自动资源关闭
try {
	// 打开资源对象
	// 该资源类必须实现java.lang.AutoCloseable接口
	out = new FileOutputStream("C://123.txt");
} catch (Exception e) {
	e.printStrackTrace();
}
```

#### 最佳实践

**自定义异常**

```java
在开发中根据自己业务的异常情况来定义异常类.

- 自定义一个受检查(编译时)的异常类: 自定义类 并继承于java.lang.Exception
- 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException
```

```java
//自定义一个业务逻辑异常: LogicException
public class LogicException extends RuntimeException {
	private static final long serialVersionUID = 1L;
	public LogicException() {
		super();
	}
	public LogicException(String message) {
		super(message);
	}
	public LogicException(String message, Throwable cause) {
		super(message, cause);
	}
}

// 抛出异常
if (name.equals(username)) {
	throw new LogicException("该用户名已经被注册");
}
```

**异常转译和异常链**

```
异常转译:
当位于最上层的子系统不需要关心底层的异常细节时
常见的做法是捕获原始的异常,把它转换为一个新的不同类型的异常,再抛出新的异常.
如: 我的车抛锚了
我在catch中重新抛出一个新的异常(LateException)给我的调用者(老板)
我们不能把车的异常信息抛给老板看
因为老板不关心这些细节,关心的我是否迟到

异常链:
把原始的异常包装为新的异常类
从而形成多个异常的有序排列
有助于查找生成异常的根本原因
```

**处理异常的原则**

```java
1:异常只能用于非正常情况,try-catch的存在也会影响性能.
2:需要为异常提供说明文档,比如Java doc,如果自定义了异常或某一个方法抛出了异常,我们应该记录在文档注释中..
3:尽可能避免异常
4:异常的粒度很重要，应该为一个基本操作定义一个 try-catch 块，不要为了简便，将几百行代码放到一个 try-catch 块中.
5:不建议在循环中进行异常处理，应该在循环外对异常进行捕获处理(在循环之外使用try-catch).
6:自定义异常尽量使用RuntimeException类型的.
```

### 常用类

#### 系统

```java
System:表示系统的意思
Runtime:表示Java的运行过程
```

#### 数学

和数学相关的三个常用类

```java
Math:Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数等,都是静态方法

BigInteger:表示大整型, 如果两个long类型的最大值相运算,结果long再也存储不下, 此时使用BigInteger

BigDecimal:float和double都不能表示精确的小数, 此时使用BigDecimal,用于处理金钱和精度要求高的数据.
	new BigDecimal(0.1), 该构造方法有一定的不可预知性. 建议优先使用new BigDecimal("0.1")

```

#### 字符串

```java
接口 CharSequence
子接口 Name
实现类 String, StringBuffer, StringBuilder, CharBuffer, Segment

字符序列: 把多个字符按照一定得顺序排列起来
字符串: 把多个字符串串联起来

字符串的分类
 - 不可变的字符串: String, 当前对象创建完毕之后, 该对象的内容(字符序列)是不能改变的, 一旦内容改变就是一个新的对象.
 - 可变的字符串: StringBuilder/StringBuffer, 当对象创建完毕之后,该对象的内容可以发生改变, 当内容发生改变的时候,对象保持不变.

字符串的本质: 底层是什么其实就是char[]
```

**String类**

```
表示不可变的字符串
当前对象创建完毕之后,该对象的内容(字符序列)是不能改变的
一旦内容改变就是一个新的对象
```

```java
1. String对象的创建
- 直接赋一个字面量: String str1 = "ABCD";
	最多创建一个String对象,最少不创建String对象. 
	如果常量池中, 已经存在”ABCD”,那么str1直接引用, 此时不创建String对象. 
	否则, 先在常量池先创建”ABCD”内存空间,再引用.

- 通过构造器创建: String str2 = new String(“ABCD”);
	最多创建两个String对象, 至少创建一个String对象.
	new关键字: 绝对会在堆空间,创建内存区域.所以至少创建一个String个对象

2. String对象的空值
- 表示引用为空(null)
	String str1 = null;      
	没有初始化,没有分配内存空间
- 内容为空字符串
	String str2 = "";   
	以及初始化,分配内存空间,不过没有内容.

3. 字符串的比较操作
- 使用”==”号: 只能比较引用的内存地址是否相同.
- 使用equals方法: String类覆盖了Object类的equals方法, 比较的是字符内容.
```

```java
// 单独使用""引号创建的字符串都是直接量, 编译期就已经确定存储到常量池中
String str1 = "ABCD";

// 使用只包含直接量的字符串连接符如"aa" + "bb"创建的也是直接量编译期就能确定
// 已经确定存储到常量池中
String str2 = "A" + "B" + "C" + "D";
String str3 = "AB" + "CD";

// 使用new String("")创建的对象会存储到堆内存中, 是运行期才创建
String str4 = new String("ABCD");

// 使用包含String直接量(无final修饰符)的字符串表达式(如"aa" + s1)创建的对象是运行期才创建的, 存储在堆中
String temp = "AB";
String str5 = temp + "CD";

// 通过变量/调用方法去连接字符串,都只能在运行时期才能确定变量的值和方法的返回值, 不存在编译优化操作.
String getXx() {
	return "AB";
}
String str6 = getXx() + "CD";
```

String类中的常用方法

```java
1):String的创建和转换:
	byte[] getBytes():把字符串转换为byte数组
	char[] toCharArray():把字符串转换为char数组
	String(byte[] bytes):把byte数组转换为字符串
	String(char[] value):把char数组转换为字符串
2):获取字符串信息
	int length() 返回此字符串的长度 
	char charAt(int index) 返回指定索引处的 char 值 
	int indexOf(String str)返回指定子字符串在此字符串中第一次出现处的索引。 
	int lastIndexOf(String str)返回指定子字符串在此字符串中最右边出现处的索引 

3):字符串比较判断
	boolean equals(Object anObject) 将此字符串与指定的对象比较。 
	boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写
	boolean contentEquals(CharSequence cs) 将此字符串与指定的 CharSequence 比较

4):字符串大小写转换
	String toUpperCase()  把当前字符串转换为大写(谁调用该方法,谁就是当前字符)
	String toLowerCase()  把当前字符串转换为小写
```

**String/StringBuilder/StringBuffer**

String和StringBuilder以及StringBuffer的区别(建议使用StringBuilder)

```java
StringBuffer和StringBuilder都表示可变的字符串,功能方法都是相同的.

唯一的区别:
StringBuffer中的方法都使用了synchronized修饰符, 表示同步的, 在多线程并发的时候可以保证线程安全,保证线程安全的时候, 性能(速度)较低
StringBuilder中的方法都没有使用了synchronized修饰符, 不安全, 但是性能较高
```
```java
StringBuilder无参数的构造器, 在底层创建了一个长度为16的char数组
char[] value = new char[16];

// 自动扩容
此时该数组只能存储16个字符, 如果超过了,得自动扩容.
自动扩容(创建长度更大的数组,再把之前的数组拷贝到新数组)
此时性能极低,一般的,我们事先知道大概需要存储多少字符,在构造器中就应该设置
 
//创建一个长度为80的char数组.
new StringBuilder(80);

常用方法:
// 表示追加任意类型数据
append(Object val);
// 删除字符串中, 指定位置的字符
StringBuilder deleteCharAt(int index);
```

#### 随机数

随机地生成的任意的一个数

```java
1. Random类
生产一个伪随机数(通过相同的种子,产生的随机数是相同的)
public Random() 使用默认的种子（以当前系统时间作为种子）
public Random(long seed) 根据指定的种子

2. ThreadLocalRandom类
Java7新增类，是Random类的子类
在多线程并发情况下，ThreadLocalRandom相对于Random可以减少多线程资源竞争
保证了线程的安全性

3. UUID类
通用惟一识别：Universally Unique Identifier； 在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的
一般用来表示:随机的唯一的字符串.
```

#### 日期

日期相关类

```java
Date类: java.util.Date类(不是java.sql.Date), 表示特定的瞬间，精确到毫秒
DateFormat/SimpleDateFormat类
Calendar类: Java8中重新为日期定义了新的API
```

**日期格式化操作**

```java
DateFormat: 可以完成日期的格式化操作, 转换的格式是固定的
- 格式化(format): Date类型对象->String类型
- 解析(parse): String类型时间->Date类型

// Date -> String
Date d = new Date();
// short
DateFormat df = DateFormate.getInstance();
String time = df.format(d);
// long
df = DateFormate.getInstance(DateFormat.LONG, DateFormat.LONG);

// String -> Date
Date d2 = df.parse(time);
```

```java
SimpleDateFormat: DateFormat的子类,支持自定义格式模式

String pattern = "yyyy-MM-dd HH:mm:ss E";
SimpleDateFormat sdf = new SimpleDateFormat();
sdf.applyPattern(pattern);

String time = sdf.format(new java.util.Date());
java.util.Date d = sdf.parse(time);
```

**日历类(Calendar)**

```java
日历类(Calendar):是抽象类, 表示日历

// 创建日历对象:
Calendar c = Calendar.getInstance();

// 返回给定日历字段(年,月,日,时,分,秒)的值
int get(int field) 
Calendar.Year;
c.get(Calendar.Year);
c.get(Calendar.Month);

// Calendar转Date
Date d = c.getTime();

// 根据日历的规则, 为给定的日历字段添加或减去指定的时间量
c.add(Calendar.Day_OF_MONTH, 1000);
```

### 正则表达式

```java
正则表达式(Regex)表示表达式正确的规则:
主要用于(匹配判断,分割操作,替换操作(网络爬虫(Lucene))):

input = "1587918297"
String regex = "^1[3|4|5|7|8]\\d{9}$";
input.matches(regx);
```

### 集合框架

#### 数据结构
#### List/Set/Map
#### Collection/Collections/Properties
#### 迭代器
#### 比较器

### 多线程

并发和并行

```
并行：指两个或多个事件在同一时刻点发生
并发：指两个或多个事件在同一时间段内发生

单CPU系统中，每一时刻却仅能有一道程序执行（时间片），故微观上这些程序只能是分时地交替执行
单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行

时间片即CPU分配给各个程序的运行时间
```

**进程和线程**

```
进程
指一个内存中运行中的应用程序, 每个进程都有自己独立的一块内存空间, 进程之间的通信很不方便

线程
指进程中的一个执行任务(控制单元)，一个进程可以同时并发运行多个线程
如：多线程下载软件。多任务系统,该系统可以运行多个进程

一个进程也可以执行多个任务, 一个进程可以包含多个线程
```

进程与线程的区别

```
进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程
线程：堆空间是共享的，栈空间是独立的，线程消耗的资源也比进程小，相互之间可以影响的，又称为轻型进程或进程元

Java程序的进程(Java的一个程序运行在系统中)里至少包含主线程和垃圾回收线程(后台线程)
```

线程调度

```
计算机通常只有一个CPU时, 在任意时刻只能执行一条计算机指令
每一个进程只有获得CPU的使用权才能执行指令
所谓多进程并发运行, 从宏观上看, 其实是各个进程轮流获得CPU的使用权, 分别执行各自的任务

那么, 在可运行池中, 会有多个线程处于就绪状态等到CPU
JVM就负责了线程的调度. JVM采用的是抢占式调度, 没有采用分时调度
因此可以能造成多线程执行结果的的随机性。
```

**多线程优势**

```
- 进程之间不能共享内存，而线程之间共享内存(堆内存)则很简单。
- 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高.
- Java语言本身内置多线程功能的支持,而不是单纯第作为底层系统的调度方式,从而简化了多线程编程
```

多线程下载

```
一个线程就是一个文件的下载通道
多线程也就是同时开起好几个下载通道
当服务器提供下载服务时，使用下载者是共享带宽的
在优先级相同的情况下，总服务器会对总下载线程进行平均分配

多线程是为了同步完成多项任务，不是为了提供程序运行效率，而是通过提高资源使用效率来提高系统的效率
```

宽带带宽

```
宽带带宽是以位（bit）计算，而下载速度是以字节（Byte）计算
1字节（Byte）等于8位（bit）, 所以1024kb/s是代表上网带宽为1024千位（1M）
而下载速度需要1024千位/秒（1024kb/s）带宽除以8得出128千字节/秒（128KB/s）
```

#### 多线程的创建与启动
#### 线程同步
#### 线程通信
#### 线程池
#### 定时器

### IO流
### 新版本JAVA特性
