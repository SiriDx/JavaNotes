## Java语言进阶

### 编码规范

```java
起名:
      1):都得遵循标识符的规范.
      2):不能使用拼音,拼音首字母,使用英文单词,或者使用英文组合单词.
      3):采用驼峰表示法,使用组合单词的使用,以后的每一个单词首字母都大写.
          EmployeeAdvanceSetting.

1:包名:
       package    域名倒写.模块名.组件;
       package    com._520it.pss.util;
       package    com.m520it.pss.util;
       全部使用小写字母,作为Java文件得第一行代码.
2:类名:
      使用名词,表示一类事物,首字母大写.
       如果我们在项目中尽量不要使用JDK内置的类名,比如String ,System类.
      讲解知识点:    XxxDemo,XxxTest,(Xxx表示知识点的意思),比如:StringDemo.java.

3:接口名:
      使用形容词/副词/名词,首字母大写.
      在有的企业,习惯以I作为接口的前缀名. IEmployeeDAO/IEmployeeService.

4:方法名:
       使用动词,首字母小写,save/deleteEmployee.

5:变量:
       使用名词,首字母小写,如name/age,.

6:常量:
       使用final修饰的变量.
       全部使用大写字母组成,如果使用多个单词组合使用下划线分割,如:Integer类:MAX_VALUE:
       在方法中定义的final变量,一般不使用大写.
```

### 工具

Eclipse...

### 异常

```java
类 Throwable
已实现的接口 Serializable
子类 Error, Exception

Throwable是所有错误和异常的父类
```

```Java
Error:表示错误, 一般指JVM相关的不可修复的错误
	如, 系统崩溃,内存溢出,JVM错误等,由JVM抛出, 我们不需要处理.
	几乎所有的子类都是以Error作为类名的后缀.
常见的Error:
	StackOverflowError: 当应用程序递归太深而发生内存溢出时，抛出该错误。 

Exception:表示异常, 指程序中出现不正常的情况, 该问题可以修复(处理异常).
	几乎所有的子类都是以Exception作为类名的后缀.
常见的Exception:
    NullPointerException: 空指针异常,一般指当对象为null的时候,调用了该对象的方法,字段
    ArrayIndexOutOfBoundsException: 数组的索引越界,(小于0或者大于等于数组长度)
    NumberFormatException: 数字格式化异常, 一般指,把非0~9的字符串转换为整数
```

#### 异常体系

```java
使用try-catch捕获单个异常,语法如下:
try{
     // 编写可能会出现异常的代码
}catch(异常类型  e){
     // 处理异常的代码
     // 记录日志/打印异常信息/继续抛出异常
}

```

#### 捕获异常
#### 异常分类
#### 抛出异常
#### Java7异常新特性
#### 最佳实践

### 常用类

#### 系统

```java
System:表示系统的意思
Runtime:表示Java的运行过程
```

#### 数学

和数学相关的三个常用类

```java
Math:Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数等,都是静态方法

BigInteger:表示大整型, 如果两个long类型的最大值相运算,结果long再也存储不下, 此时使用BigInteger

BigDecimal:float和double都不能表示精确的小数, 此时使用BigDecimal,用于处理金钱和精度要求高的数据.
	new BigDecimal(0.1), 该构造方法有一定的不可预知性. 建议优先使用new BigDecimal("0.1")

```

#### 字符串

```java
接口 CharSequence
子接口 Name
实现类 String, StringBuffer, StringBuilder, CharBuffer, Segment

字符序列: 把多个字符按照一定得顺序排列起来
字符串: 把多个字符串串联起来

字符串的分类
 - 不可变的字符串: String, 当前对象创建完毕之后, 该对象的内容(字符序列)是不能改变的, 一旦内容改变就是一个新的对象.
 - 可变的字符串: StringBuilder/StringBuffer, 当对象创建完毕之后,该对象的内容可以发生改变, 当内容发生改变的时候,对象保持不变.

字符串的本质: 底层是什么其实就是char[]
```

**String类**

```
表示不可变的字符串
当前对象创建完毕之后,该对象的内容(字符序列)是不能改变的
一旦内容改变就是一个新的对象
```

```java
1. String对象的创建
- 直接赋一个字面量: String str1 = "ABCD";
	最多创建一个String对象,最少不创建String对象. 
	如果常量池中, 已经存在”ABCD”,那么str1直接引用, 此时不创建String对象. 
	否则, 先在常量池先创建”ABCD”内存空间,再引用.

- 通过构造器创建: String str2 = new String(“ABCD”);
	最多创建两个String对象, 至少创建一个String对象.
	new关键字: 绝对会在堆空间,创建内存区域.所以至少创建一个String个对象

2. String对象的空值
- 表示引用为空(null)
	String str1 = null;      
	没有初始化,没有分配内存空间
- 内容为空字符串
	String str2 = "";   
	以及初始化,分配内存空间,不过没有内容.

3. 字符串的比较操作
- 使用”==”号: 只能比较引用的内存地址是否相同.
- 使用equals方法: String类覆盖了Object类的equals方法, 比较的是字符内容.
```

```java
// 单独使用""引号创建的字符串都是直接量, 编译期就已经确定存储到常量池中
String str1 = "ABCD";

// 使用只包含直接量的字符串连接符如"aa" + "bb"创建的也是直接量编译期就能确定
// 已经确定存储到常量池中
String str2 = "A" + "B" + "C" + "D";
String str3 = "AB" + "CD";

// 使用new String("")创建的对象会存储到堆内存中, 是运行期才创建
String str4 = new String("ABCD");

// 使用包含String直接量(无final修饰符)的字符串表达式(如"aa" + s1)创建的对象是运行期才创建的, 存储在堆中
String temp = "AB";
String str5 = temp + "CD";

// 通过变量/调用方法去连接字符串,都只能在运行时期才能确定变量的值和方法的返回值, 不存在编译优化操作.
String getXx() {
	return "AB";
}
String str6 = getXx() + "CD";
```

String类中的常用方法

```java
1):String的创建和转换:
	byte[] getBytes():把字符串转换为byte数组
	char[] toCharArray():把字符串转换为char数组
	String(byte[] bytes):把byte数组转换为字符串
	String(char[] value):把char数组转换为字符串
2):获取字符串信息
	int length() 返回此字符串的长度 
	char charAt(int index) 返回指定索引处的 char 值 
	int indexOf(String str)返回指定子字符串在此字符串中第一次出现处的索引。 
	int lastIndexOf(String str)返回指定子字符串在此字符串中最右边出现处的索引 

3):字符串比较判断
	boolean equals(Object anObject) 将此字符串与指定的对象比较。 
	boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写
	boolean contentEquals(CharSequence cs) 将此字符串与指定的 CharSequence 比较

4):字符串大小写转换
	String toUpperCase()  把当前字符串转换为大写(谁调用该方法,谁就是当前字符)
	String toLowerCase()  把当前字符串转换为小写
```

**String/StringBuilder/StringBuffer**

String和StringBuilder以及StringBuffer的区别(建议使用StringBuilder)

```java
StringBuffer和StringBuilder都表示可变的字符串,功能方法都是相同的.

唯一的区别:
StringBuffer中的方法都使用了synchronized修饰符, 表示同步的, 在多线程并发的时候可以保证线程安全,保证线程安全的时候, 性能(速度)较低
StringBuilder中的方法都没有使用了synchronized修饰符, 不安全, 但是性能较高
```
```java
StringBuilder无参数的构造器, 在底层创建了一个长度为16的char数组
char[] value = new char[16];

// 自动扩容
此时该数组只能存储16个字符, 如果超过了,得自动扩容.
自动扩容(创建长度更大的数组,再把之前的数组拷贝到新数组)
此时性能极低,一般的,我们事先知道大概需要存储多少字符,在构造器中就应该设置
 
//创建一个长度为80的char数组.
new StringBuilder(80);

常用方法:
// 表示追加任意类型数据
append(Object val);
// 删除字符串中, 指定位置的字符
StringBuilder deleteCharAt(int index);
```

#### 随机数

随机地生成的任意的一个数

```java
1. Random类
生产一个伪随机数(通过相同的种子,产生的随机数是相同的)
public Random() 使用默认的种子（以当前系统时间作为种子）
public Random(long seed) 根据指定的种子

2. ThreadLocalRandom类
Java7新增类，是Random类的子类
在多线程并发情况下，ThreadLocalRandom相对于Random可以减少多线程资源竞争
保证了线程的安全性

3. UUID类
通用惟一识别：Universally Unique Identifier； 在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的
一般用来表示:随机的唯一的字符串.
```

#### 日期

日期相关类

```java
Date类: java.util.Date类(不是java.sql.Date), 表示特定的瞬间，精确到毫秒
DateFormat/SimpleDateFormat类
Calendar类: Java8中重新为日期定义了新的API
```

**日期格式化操作**

```java
DateFormat: 可以完成日期的格式化操作, 转换的格式是固定的
- 格式化(format): Date类型对象->String类型
- 解析(parse): String类型时间->Date类型

// Date -> String
Date d = new Date();
// short
DateFormat df = DateFormate.getInstance();
String time = df.format(d);
// long
df = DateFormate.getInstance(DateFormat.LONG, DateFormat.LONG);

// String -> Date
Date d2 = df.parse(time);
```

```java
SimpleDateFormat: DateFormat的子类,支持自定义格式模式

String pattern = "yyyy-MM-dd HH:mm:ss E";
SimpleDateFormat sdf = new SimpleDateFormat();
sdf.applyPattern(pattern);

String time = sdf.format(new java.util.Date());
java.util.Date d = sdf.parse(time);
```

**日历类(Calendar)**

```java
日历类(Calendar):是抽象类, 表示日历

// 创建日历对象:
Calendar c = Calendar.getInstance();

// 返回给定日历字段(年,月,日,时,分,秒)的值
int get(int field) 
Calendar.Year;
c.get(Calendar.Year);
c.get(Calendar.Month);

// Calendar转Date
Date d = c.getTime();

// 根据日历的规则, 为给定的日历字段添加或减去指定的时间量
c.add(Calendar.Day_OF_MONTH, 1000);
```

### 正则表达式

```java
正则表达式(Regex)表示表达式正确的规则:
主要用于(匹配判断,分割操作,替换操作(网络爬虫(Lucene))):

input = "1587918297"
String regex = "^1[3|4|5|7|8]\\d{9}$";
input.matches(regx);
```

### 集合框架
### 多线程
### IO流
### 新版本JAVA特性
